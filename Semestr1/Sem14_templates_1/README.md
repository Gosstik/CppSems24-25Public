# Семинар 14. Шаблоны 1

- Явные специализации нужно писать только после объявления шаблона, иначе CE.

- Если пишем специализацию, то `template<> ...`, если хотим инстанциацию по шаблону, то пишем `template ...`.

### TODO

- lecture 1, metaprogramming
- lecture 3, vladimirov
- __PRETTY_FUNTION__: <https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html>. В глобал скоупе будет "top level".

- Вам не кажется это безумием?
- Логика: функции --- это отображения из значений в значения
- Шаблоны --- метафункции --- отображение из типа в тип
- Шаблонный шаблонный аргумент --- это по сути метафункция (или указатель на неё). Мы можем подставлять в неё тип и получать тип
- Неявные сппециализации --- те, которые генерируются по главному шаблону. Для концептов разрешены только они. Для юзингов вроде тоже, но нужно проверить (возможно, полная явная специализация тоже разрешена)
- Запомнить это сейчас всё невозможно и все тонкости всегда помнить тоже проблематично. Моя цель --- чтобы у вас где-то отложилось, что тут есть некоторые закарюки, чтобы при встрече с таким вы не удивлялись и понимали, что нужно гуглить.

- require clause
- require expression

- Можно воспринимать принимаемые аргументы как квантор всеобщности по ним
- Какое отличие между `concept` и `constexpr bool`? --- У них по-разному работают || и \&\&.
- ConstructibleFrom (важен порядок аргументов)
- Swappable (universal references)

- lect3

- compound requires expression, noexcept
- requires inside requires (we want true, not only compilation) - можно было просто написать &&. Очередная пушка нам в ноги
- при определении концепта нельзя в шаблонный аргумент писать другой концепт или requires.
- requires проверяет только синтаксические требования. Семантические проверить нельзя (из-за проблемы остановки). Например, что элементы в памяти лежат последовательно или требование на сравнения. Разница между "концепт смоделирован" и "концепт удовлетворён".
- equality preservation (expression e is equally preservable)
- equality stability
- Пример, когда в requires вызывается приватная функция (reqiures выдаст false, потому что он как раз проверяет компиляцию)
- std::move_constructible для ссылки на класс с удалённым конструктором (мораль: нужно не пихать ссылки в концепты)

- lect5

- ADL --- Argument Dependent Lookup (привести пример)
- Вызов функции в C++:
  1) Name lookup
  2) Type deduction, template instantiation, constraints
  3) Overload resolution на множестве имён

- CRTP --- Curiously Recurring Template Pattern. Работает благодаря ленивой инстанциации методов.
- CRTP абьюзит two phase lookup, но в msvc он реализован криво, поэтому некоторые методы и приёмы могут не работать.
- CRTP позволяет использовать часть механизма виртуальных функций, при этом всё происходит в компайл тайме, так что получается быстрее
- Пример с клоном для фигур
- std::enable_shared_from_this, std::ranges::view_interface
- barton-nackman: crtp+adl+friends --- был актуален, когда не было <=>
- С++23 deducing this --- более мощная поддержка this

- lect 6
- В C++11 появились variadic-и, но главная их проблема --- нельзя передать в функцию несколько вариадиков (если это не tuple). А также нельзя довольно просто взять i-ый тип. Мы по сути хотим автоматически создавать код для абстрактной фабрики
- Реулизуем type_list

- lect 7
- Идея Traits, std::iterator_traits, разобрать реализации iterator_traits
- Паттерн стратегия
- Static strategy == Policy
- Policy Based Design
- pb_ds
- mixins
- Важное правило: если делается наследование, то нужно использовать либо виртуальный деструктор, либо приватный (protected) деструктор в зависимости от того, какое поведение мы хотим.
- libstdc++/ext/pd_ds (в стандартной библиотеке плюсов от gcc)
- Аллокаторы - это тоже в каком-то смысле политики, только мы принимаем не шаблонный аллокатор.
- Включение и выключение виртуальности с помощью шаблонных аргументов


- lect 8 (Полиморфизм)
- Свойства полиморфизма:
  - Статический и динамический
- На уровне значений плюсы строго типизированный язык, а вот на уровне типов (шаблонов) --- грубо говоря нет (в шаблонную функцию любое значение можем передать)
- Шаблонный полиморфизм


- lect 9 (std::function)


- lect 11 (ниблоиды и генерация иерархий)
- Ниблоиды - убийство ADL
- Кастомизация свопа!!!! - это заклинания и так никто в проде не делает - лучше показать, как специализировать шаблон своп в своём коде
- Фейковую ноду в листе называют сентинелой (sentinel). Вообще, sentinel - это что-то про граничное значение.
- 


Новые лекции

- У хроно и у string_view есть свои литеральные суффиксы.
- 


# Семинар 1

## Базовые команды терминала Ubuntu

Все обозначения в угловых скобках (вида `<name>`) &mdash; плейсхолдеры. Это значит, что вы можете вставлять туда разные значения в зависимости от контекста.

```bash
echo $USER # Вывести имя текущего пользователя
whoami # Второй способ вывести имя пользователя

pwd # Абсолютный путь до текущей (рабочей) директории

ls # Содержимое текущей директории
ls <dirname> # Содержимое директории <dirname>
ls --list # Вывести подробную информацию о каждом файле
ls -l # Аналогично команде выше, но короче
ls --all # Показать также скрытые файлы
ls -a # Аналогично команде выше, но короче
ls --human-readable # human readable размер файлов (килобайты, мегабайты, ...)
ls -h # Аналогично команде выше, но короче
ls -R # Вывести файлы рекурсивно по всем подпапкам

# Можно использовать несколько флагов одновременно (работает для всех команд терминала со своими флагами)
ls --list --all --human-readable
ls -l -a -h # Более короткая запись
ls -lah # Ещё короче

# Если нужно больше флагов или вы забыли, за что они отвечают
ls --help

# Переход по директориям
cd .. # Директория на уровень выше
cd - # Предыдущая посещённая директория
cd ~ # Домашняя директория
cd ~<username> # Домашняя директория пользователя <username>

mkdir <dir> # Создать директорию <dir>
mkdir -p <path>/<to>/<dir> # Создать директорию и все промежуточные при необходимости

touch <name> # Так можно создать файл, но сама команда делает немного другое

cat <file> # Вывести содержимое файла

# Открытие файлов в разных текстовых редакторах
nano <file>
vim <file>

cp <file> <new_file> # Скопировать файл. Вместо названия файла можно указывать путь до него
mv <file> <new_file> # Переместить файл (предыдущий удаляется)
rm <file> # Удалить файл

grep <pattern> <file> # Вывести строки с вхождением <pattern> в файле <file>
grep -n <pattern> <file> # Вывести также номер строки

cat <file> | grep <pattern>

head -9 <file> # Вывести первые 9 строк файла
tail -7 <file> # Вывести последние 7 строк файла

sudo apt-get update # Проверить обновления для установленных команд (обновить состояние индекса из репозиториев)
sudo apt-get upgrade # Установить обновления, которые мы нашли предыдущей командой
```

Важно помнить, что тут перечислены далеко не все команды и их флаги, а только самые распространённые и наиболее часто используемые в повседневной жизни. Если вам нужно что-то экзотическое --- первым делом загуглите. Если же вы знаете, что какая-то команда делает нужное вам действие, но вы забыли флаг или синтаксис --- можно написать `<cmd> --help` (но это работает не всегда). Также документацию можно попробовать найти в мане: `man <cmd>`.

Скрытыми файлами/папками в линуксе считаются **те и только те файлы**, которые начинаются с точки. Например, `.bashrc`, `.`, `..`. `.` и `..` &mdash; это ссылки на текущую папку и на папку на уровень выше. То есть если мы находимся в `/usr/lib`, то `ls .` выведет содержимое папки `/usr/lib`, а `ls ..` выведет содержимое папки `/usr/`.

Важно помнить, что, с точки зрения прав, есть 3 способа взаимодействия с файлом и 3 возможных категории доступа к файлу.

Способы взаимодействия с файлом:

- r &mdash; чтение файла
- w &mdash; запись в файл
- e &mdash; исполнение файла (чтобы мы могли запустить файл как программу)

Категории доступа:

- u &mdash; доступ к файлу для пользователя, который его создал
- g &mdash; доступ к файлу для группы пользователей, к которой принадлежит юзер
- o &mdash; доступ к файлу остальным пользователям

Менять эти доступы можно с помощью команды `chmod`. Например так:

```bash
chmod o+x # Разрешить всем остальным пользователям запускать файл
chmod g-w # Запретить группе пользователей изменять файл
chmod +r # Разрешить юзеру, группе и всем остальным пользователям читать файл
```

Ещё к каждой команде можно добавить префикс `sudo`. Этот префикс будет означать, что мы выполняем команду от имени пользователя `root` --- то есть у нас больше прав для выполнения команды. Например, это может понадобиться для записи каких-то файлов в директорию `/bin` или `/usr/bin/`, куда у обычного пользователя есть право только на чтение.

## Shortcuts

Для быстрой навигации можно использовать специальные клавиатурные сокращения. Часто в документациях можно видеть обозначения `<C-v>` или `^V`. Они обозначают сокращение `ctrl+V`. Вместо `v` может быть написана другая буква :)

- Когда набираете путь, можно набрать первые n букв и нажать `tab`. Тогда произойдёт автодополнение пути. Если вариантов несколько, то нужно нажать `tab` ещё раз и будут выведены возможные варианты

- Для повторного выполнения команды, которая использовалась раньше, можно использовать стрелки `&uarr;` и `&darr;` &mdash; это выведет предыдущую и следующую команды соответственно.

- `ctrl+A` и `ctrl+E` &mdash; переместиться в начало/конец строки терминала

- Для перемещения вправо-влево по строке терминала используются стрелки `&larr;` и `&rarr;`. Чтобы перемещаться быстрее (не по одному символу, а по одному слову за клик), можно зажать клавишу `alt`

- `ctrl+E` &mdash; переместиться в начало/конец строки терминала

- `ctrl+W` &mdash стереть всё предыдущее слово

- `ctrl+U` &mdash стереть всю строку

- `ctrl+R` &mdash поиск по предыдущим командам. Лучше установить `fzf finder` [отсюда](https://github.com/junegunn/fzf) и там же посмотреть документацию по использованию


## Сигналы

Исполняющиеся файлы могут взаимодействовать с операционной системой через специальные сигналы. Посылать эти сигналы можно из терминала с помощью шорткатов. Несколько распространённых:

- `ctrl+D` &mdash; отправить программе сигнал EOF (End Of File)

- `ctrl+С` или `ctrl+/` &mdash; принудительно завершить программу, но дать возможность завершить/сохранить некоторые критически важные компоненты

- `ctrl+U` &mdash; "убить" программу. Не даёт возможности программе исполняться дальше ни при каких обстоятельствах

Шорткаты могут различаться для разных дистрибутивов. Посмотреть список всех шорткатов для сигналов можно командой (на Ubuntu):

```bash
# Ubuntu
stty -a

# BSD
stty -e
```

Также сигналы можно передавать, используя утилиту `kill` и `pid` процесса (можно почитать [тут](https://losst.pro/kak-ubit-protsess-linux)). Так можно использовать гораздо больше сигналов, но мы не будем вдаваться в такие подробности.


## Компиляторы

Сейчас активно используются и поддерживаются 3 компилятора: `g++`, `clang++` и `msvc`. Последний из  них широко используется на OS Windows, мы же в курсе будем полагаться только на первые 2.

Про установку свежих версий компиляторов можно почитать тут: [gcc](https://github.com/Gosstik/SoftDocs/blob/master/gcc/gcc-installation.md), [clang](https://github.com/Gosstik/SoftDocs/blob/master/clang/clang-installation.md).

Посмотреть, какую версию компилятора вы используете сейчас, можно с помощью флага `--version`:

```bash
g++ --version
readlink -f /bin/g++ # Посмотреть путь до файла, на который ссылается g++
```

**Важно** версия компилятора != версия стандарта.

Команда для компиляции программы и некоторые её флаги:

```bash
g++ main.cpp # Обычная компиляция, на выходе получаем a.out
./a.out # Запускаем скомпилированную программу

g++ main.cpp -o main.exe # Вместо a.out результат будет в main.exe
./main.exe

g++ -std=c++20 main.cpp -o main.out # Явно указываем, какой стандарт использовать
```
